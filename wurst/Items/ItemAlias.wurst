package ItemAlias
import ItemObjEditing
import ObjectIdGenerator

import ClosureEvents
import ClosureTimers
import LinkedList
import LinkedListModule
import HashMap


/* An item alias is an item that copies all the fields of a specific item,
except its ability list and with "Use Automatically When Aquired" field
set to "true". When a unit picks up an alias the trigger gives the unit
the actual item. When a unit drops an item, the item is removed and the actual
alias is created.
Such aliases are used to bypass the error message when a unit is trying
to pick up an item with no empty inventory slots. For example, when a hero
needs to pick up a stackable item with no empty slot but with such an item
in the inventory, or when an item's gonna be combined with other items but
it can't be done because of the annoying mechanic. */


public abstract class ItemAlias
	use LinkedListModule

	abstract function call(unit u, item givenItem)

	/** Called when the hero either has or doesn't have an empty slot for the item.
	The actual item will be removed from the map and replaced with its alias right
	after the callback's executed. */
	static function onPickUp(ItemAlias cb) returns ItemAlias
		return cb

	// Compiletime 

	// Transfered data
	protected static let itemIds = compiletime(new LinkedList<int>)
	protected static let aliasIds = compiletime(new LinkedList<int>)

	abstract static class BuildCallback
		abstract function call(ItemDefinition def, bool isAlias)

	static function build(ItemDefinition actualItemDef, ItemDefinition aliasItemDef, BuildCallback buildCb)
		buildCb.call(actualItemDef, false)
		buildCb.call(aliasItemDef, true)
		actualItemDef.setUseAutomaticallyWhenAcquired(false)
		aliasItemDef..setUseAutomaticallyWhenAcquired(true)
		..setAbilities("")
		itemIds.add(actualItemDef.getNewId())
		aliasIds.add(aliasItemDef.getNewId())
		destroy buildCb
	
	static function build(int actualItemId, int aliasItemId, BuildCallback buildCb)
		build(new ItemDefinition(actualItemId, 'afac'), new ItemDefinition(aliasItemId, 'afac'), buildCb)
	
	static function build(int actualItemId, BuildCallback buildCb)
		build(actualItemId, ITEM_ID_GEN.next(), buildCb)

	static function build(BuildCallback buildCb)
		build(ITEM_ID_GEN.next(), ITEM_ID_GEN.next(), buildCb)

	protected static function _init()
		let itemFromAlias = new HashMap<item, item>

		EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) () ->
			let aliasItem = EventData.getManipulatedItem()
			let aliasItemId = aliasItem.getTypeId()
			if aliasIds.has(aliasItemId)
				let u = EventData.getTriggerUnit()
				let pos = aliasItem.getPos()
				let p = aliasItem.getPlayer()
				let charges = aliasItem.getCharges()
				aliasItem.remove()
				let isInventoryFull = u.isInventoryFull()
				let index = aliasIds.indexOf(aliasItemId)
				let actualItemId = itemIds.get(index)
				let newItem = not isInventoryFull ? u.addItemById(actualItemId) : createItem(actualItemId, pos)
				newItem..setPlayer(p, true)
				..setCharges(charges)
				for cb in ItemAlias
					cb.call(u, newItem)
				if newItem.getTypeId() != 0 and isInventoryFull
					newItem.remove()
					createItem(aliasItemId, pos)
					..setPlayer(p, true)
					..setCharges(charges)

		EventListener.add(EVENT_PLAYER_UNIT_DROP_ITEM) ->
			let droppedItem = EventData.getManipulatedItem()
			let droppedItemId = droppedItem.getTypeId()
			if itemIds.has(droppedItemId)
				nullTimer() () ->
					let p = droppedItem.getPlayer()
					let pos = droppedItem.getPos()
					let charges = droppedItem.getCharges()
					let data = droppedItem.getUserData()
					droppedItem.setVisible(false)
					let index = itemIds.indexOf(droppedItemId)
					let _alias = createItem(aliasIds.get(index), pos)
					..setPlayer(p, true)
					..setCharges(charges)
					..setUserData(data)
					itemFromAlias.put(_alias, droppedItem)


init
	ItemAlias._init()