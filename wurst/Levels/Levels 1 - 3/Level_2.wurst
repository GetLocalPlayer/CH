package Level_2
import OrderIds
import LinkedList
import HashMap
import ForceProperties
import LevelTimerModule
import ScaledLevel
import Preloader

let normalId = 'n00E'
let eliteId = 'n01G'

// Per patrol rect
let normalCount = 6
let eliteCount = 2

let entrance = gg_rct_Level_2_Entrance
let exit = gg_rct_Level_2_Portal

// Clouterclockwise
let patrolRects = asList<rect>(
	gg_rct_Level_2_Top_Left,
	gg_rct_Level_2_Bottom_Left,
	gg_rct_Level_2_Bottom_Right,
	gg_rct_Level_2_Top_Right)

let waves = 2
let delay = 4.


public class Level_2 extends ScaledLevel
	use LevelTimerModule
	private let orders = new HashMap<unit, rect>

	private static let instance = new Level_2(entrance, exit.getCenter(), waves)

	static function instance() returns Level_2
		return instance

	private construct(rect entrance, vec2 exit, int wavesCount)
		super(entrance, exit, wavesCount)
		let cond = Condition() ->
			let u = EventData.getTriggerUnit()
			return 	Level_2.instance().isInProgress()
					and u.isAlive()
					and (u.getTypeId() == normalId or u.getTypeId() == eliteId)
					and u.getOwner() == enemyPlayer

		for rct in patrolRects
			CreateTrigger()
			..registerRectEnterEventSource(rct)
			..addCondition(cond)
			..addAction() ->
				let triggeredRct = GetTriggeringTrigger().getSourceRect()
				let index = patrolRects.indexOf(triggeredRct)
				let u = EventData.getTriggerUnit()
				let targetRct = index < patrolRects.size() - 1 ? patrolRects.get(index + 1) : patrolRects.get(0)
				u.issuePointOrderById(OrderIds.attack, targetRct.getCenter())
				Level_2.instance().orders.put(u, targetRct)

	override function onInit()
		let g = CreateGroup()
		for w = 1 to getMaxWaves()
			for i = 1 to normalCount * patrolRects.size()
				g.add(createUnit(enemyPlayer, normalId, entrance.randomPoint(), GetRandomReal(1, 360).asAngleDegrees()))
			for i = 1 to eliteCount * patrolRects.size()
				g.add(createUnit(enemyPlayer, eliteId, entrance.randomPoint(), GetRandomReal(1, 360).asAngleDegrees()))
			for u from g
				u..pause()
				..setInvulnerable(true)
				..hide()
				addEnemy(u, w)
		g.destr()

	override protected function onEnemyDeath(unit u)
		orders.remove(u)
		super.onEnemyDeath(u)

	override function onRun(int waveNumber)
		if waveNumber == 1
			doPeriodically(0.5) (cb) ->
				for i = 1 to getMaxWaves()
					for u in getAliveEnemies(i)
						u..setX(u.getX())
						..setY(u.getY())
						if u.getCurrentOrder() == OrderIds.stop or u.getCurrentOrder() == 0
							u.issuePointOrderById(OrderIds.attack, orders.get(u).getCenter())

		doAfter(delay) -> 
			if GetRandomBoolean()
				/* I want to move the creeps randomly clockwise or
				counterclockwise in each wave, so I randomly revert
				the list on each wave. */
				for i = 1 to patrolRects.size() - 1
					patrolRects.addtoStart(patrolRects.removeAt(i))
			let normal = CreateGroup()
			let elites = CreateGroup()
			for u in getAliveEnemies(waveNumber)
				if u.getTypeId() == normalId
					normal.add(u)
				if u.getTypeId() == eliteId
					elites.add(u)
			for r in patrolRects
				for i = 1 to normalCount
					normal.next()
					..unpause()
					..setInvulnerable(false)
					..show()
					..setXY(r.getCenter())
				for i = 1 to eliteCount
					elites.next()
					..unpause()
					..setInvulnerable(false)
					..show()
					..setXY(r.getCenter())
			normal.destr()
			elites.destr()

	override function onFinish()
		clearTimers()

	override function onReset()
		clearTimers()
		orders.flush()

init
	preloadUnit(normalId)
	preloadUnit(eliteId)
			