package Level_2
import OrderIds
import LinkedList
import HashMap
import ForceProperties
import ClosureTimers
import ScaledLevel
import Preloader

let normalId = 'n00E'
let eliteId = 'n01G'

// Per patrol rect
let normalCount = 6
let eliteCount = 2

let entrance = gg_rct_Level_2_Entrance
let exit = gg_rct_Level_2_Portal

// Clouterclockwise
let patrolRects = asList<rect>(
	gg_rct_Level_2_Top_Left,
	gg_rct_Level_2_Bottom_Left,
	gg_rct_Level_2_Bottom_Right,
	gg_rct_Level_2_Top_Right)

let waves = 2
let delay = 4.


public class Level_2 extends ScaledLevel
	private CallbackSingle delayWaveCb = null
	private CallbackPeriodic orderCheckCb = null
	private let orders = new HashMap<unit, rect>

	private static let instance = new Level_2(entrance, exit.getCenter(), waves)

	static function instance() returns Level_2
		return instance

	private construct(rect entrance, vec2 exit, int wavesCount)
		super(entrance, exit, wavesCount)
		let cond = Condition() ->
			let u = EventData.getTriggerUnit()
			return 	Level_2.instance().isInProgress()
					and u.isAlive()
					and (u.getTypeId() == normalId or u.getTypeId() == eliteId)
					and u.getOwner() == enemyPlayer

		for rct in patrolRects
			CreateTrigger()
			..registerRectEnterEventSource(rct)
			..addCondition(cond)
			..addAction() ->
				let triggeredRct = GetTriggeringTrigger().getSourceRect()
				let index = patrolRects.indexOf(triggeredRct)
				let u = EventData.getTriggerUnit()
				let targetRct = index < patrolRects.size() - 1 ? patrolRects.get(index + 1) : patrolRects.get(0)
				u.issuePointOrderById(OrderIds.attack, targetRct.getCenter())
				Level_2.instance().orders.put(u, targetRct)

	override function onInit()
		let g = CreateGroup()
		for w = 1 to getMaxWaves()
			for i = 1 to normalCount * patrolRects.size()
				g.add(createUnit(enemyPlayer, normalId, entrance.randomPoint(), GetRandomReal(1, 360).asAngleDegrees()))
			for i = 1 to eliteCount * patrolRects.size()
				g.add(createUnit(enemyPlayer, eliteId, entrance.randomPoint(), GetRandomReal(1, 360).asAngleDegrees()))
			print("init g size = " + g.size().toString())
			for u from g
				u..pause()
				..setInvulnerable(true)
				//..hide()
				addEnemy(u, w)
		g.destr()

	override protected function onEnemyDeath(unit u)
		orders.remove(u)
		super.onEnemyDeath(u)

	override function onRun(int waveNumber)
		if waveNumber == 1
			orderCheckCb = doPeriodically(0.5) (CallbackPeriodic cb) ->
				for i = 1 to getMaxWaves()
					for u in getAliveEnemies(i)
						u..setX(u.getX())
						..setY(u.getY())
						if u.getCurrentOrder() == OrderIds.stop or u.getCurrentOrder() == 0
							u.issuePointOrderById(OrderIds.attack, orders.get(u).getCenter())

		delayWaveCb = doAfter(delay) -> 
			delayWaveCb = null
			if GetRandomBoolean()
				/* I want to move the creeps randomly clockwise or
				counterclockwise in each wave, so I randomly revert
				the list on each wave. */
				for i = 1 to patrolRects.size() - 1
					//patrolRects.addtoStart(patrolRects.removeAt(i))
			let g = CreateGroup()
			var a = 0
			var b = 0
			for r in patrolRects
				var eCount = eliteCount
				var nCount = normalCount
				for u in getAliveEnemies(waveNumber)
					if nCount > 0 and u.getTypeId() == normalId
						g.add(u)
						nCount--
					if eCount > 0 and u.getTypeId() == eliteId
						g.add(u)
						eCount--
					if nCount == 0 and eCount == 0
						break
				for u from g
					u..unpause()
					..setInvulnerable(false)
					..show()
					..setXY(r.getCenter())
					b++
				a++
			print("a = {0}".format(a.toString()))
			print("b = {0}".format(b.toString()))
			g.destr()

	override function onFinish()
		if delayWaveCb != null
			destroy delayWaveCb
			delayWaveCb = null
		destroy orderCheckCb
		orderCheckCb = null

	override function onReset()
		if delayWaveCb != null
			destroy delayWaveCb
			delayWaveCb = null
		if orderCheckCb != null
			destroy orderCheckCb
		orders.flush()

init
	preloadUnit(normalId)
	preloadUnit(eliteId)
			