package Level
import Portal
import LinkedList
import ClosureEvents
import HashMap
import InitCustomHero
import ErrorHandling
import Base


/**
	`Level` is an abstract class that defince a primitive level
	behaviour.

	A level is started when every alive customHero enters the
	level's entrance once (don't have to be in the rect all
	the time).

	Children must implement methods:
		onInit()
			// called before the very first wave is run
		onRun(int waveNumber)
			// called on each wave
		onFinish()
			// called when all enemies added via `addEnemy` are died
		onReset()
			// called when level is reset, used to clear the level and set everything again

	A level is over when all enemies are dead. Any enemy must be
	registered via `addEnemy(unit u)`, create all enemy units
	involved into a level and hide/show them in the level progress.
	This function can be called only in `onInit()` method. Registered
	enemies are also used in bar.
	The progress bar is using the enemies health to define what 
	part of the bar is coresponding to the enemy's death.
*/


let regionData = new HashMap<region, int>

function region.setData<T>(T data)
	regionData.put(this, data castTo int)

function region.getData<T>() returns T
	return regionData.get(this) castTo T


public abstract class Level
	private var maxWaves = 0
	private var waveCount = 0
	private let entranceReg = CreateRegion()
	private rect entranceRect  
	private let readyCustomHeroes = CreateGroup()
	private let aliveEnemies = new LinkedList<group>
	private let deadEnemies = new LinkedList<group>

	private var started = false
	private var finished = false
	private var initializing = false
	private Portal portal = null
	private vec2 exit

	private static let regTrg = CreateTrigger()
	private static let levels = new LinkedList<Level>

	construct(rect entrance, vec2 exit, int waves)
		_construct(entrance, exit, waves)

	construct(rect entrance, vec2 exit)
		_construct(entrance, exit, 1)

	private function _construct(rect entrance, vec2 exit, int maxWaves)
		this.entranceReg.addRect(entrance)
		this.exit = exit
		this.entranceRect = entrance
		this.maxWaves = maxWaves
		for i = 1 to maxWaves
			aliveEnemies.add(CreateGroup())
			deadEnemies.add(CreateGroup())
		regTrg.registerEnterRegion(this.entranceReg, null)
		this.entranceReg.setData<Level>(this)
		levels.add(this)

	ondestroy
		entranceReg.destr()
		readyCustomHeroes.destr()
		for i = 0 to maxWaves - 1
			aliveEnemies.get(i).destr()
			deadEnemies.get(i).destr()
		destroy aliveEnemies
		destroy deadEnemies
		destroy portal
		levels.remove(this)

	abstract function onInit()
	abstract function onRun(int waveNumber)
	abstract function onFinish()
	abstract function onReset()

	private function start()
		var aliveCount = 0
		for u in customHeroes
			if u.isAlive()
				aliveCount++
		for u in readyCustomHeroes
			if u.isAlive()
				aliveCount--
		if aliveCount == 0
			if started
				error("Cannot start a level in progress.")
			if finished
				error("Cannot start a finished Level, reset it first.")
			initializing = true
			onInit()
			initializing = false
			started = true
			runNextWave()

	private function runNextWave()
		waveCount++
		onRun(waveCount)
		
	private function finish()
		if finished
			error("Cannot finish a finished level.")
		finished = true
		started = false
		onFinish()
		if finished
			portal = new Portal(exit, (u) -> u == u.getOwner().getCustomHero())
			..addDestination(baseEntranceRect)

	private function onEnemyDeath(unit u)
		deadEnemies.get(waveCount - 1).add(u)
		let alive = aliveEnemies.get(waveCount - 1)
		alive.remove(u)
		if alive.isEmpty()
			if waveCount == maxWaves
				finish()
			else
				runNextWave()

	private function onEnemyRevived(unit u)
		deadEnemies.get(waveCount - 1).remove(u)
		aliveEnemies.get(waveCount - 1).add(u)

	function reset()
		if not finished
			error("Cannot reset a level that's not finished.")
		finished = false
		started = false
		onReset()
		waveCount = 0
		readyCustomHeroes.clear()
		for i = 0 to maxWaves - 1
			for u from aliveEnemies.get(i)
				u.remove()
			for u from deadEnemies.get(i)
				u.remove()
		if portal != null
			destroy portal
			portal = null

	function getEntrance() returns rect
		return entranceRect
	
	function getWaveCount() returns int
		return maxWaves

	function getCurrentWave() returns int
		return waveCount

	function getAliveEnemies() returns group
		return not finished and started ? aliveEnemies.get(waveCount - 1) : null

	protected function addEnemy(unit u, int wave) returns bool
		if not initializing
			error("`addEnemy(unit)` can be called only during level initialization.")
		if wave > maxWaves
			error("This level can have only {0} waves, but {1} given!".format(maxWaves.toString(), wave.toString()))
		return aliveEnemies.get(wave - 1).add(u) > 0

	private function onEnter(unit u)
		if not finished and not started and not readyCustomHeroes.has(u)
			readyCustomHeroes.add(u)
			if canStart()
				start()

	private function onCustomHeroDeath(unit u)
		if not finished and not started and not readyCustomHeroes.has(u)
			if canStart()
				start()

	private function onPlayerLeave(player p)
		if not finished and not started
			let u = p.getCustomHero()
			readyCustomHeroes.remove(u)
			if canStart()
				start()

	private function canStart() returns bool
		var aliveCount = 0
		for u in customHeroes
			if u.isAlive()
				aliveCount++
		for u in readyCustomHeroes
			if u.isAlive()
				aliveCount--
		return aliveCount == 0

	protected static function initClass()
		regTrg.addCondition(Condition(() -> begin
			let u = EventData.getEnteringUnit()
			return u.isAlive() and customHeroes.has(u)
		end))
		regTrg.addAction() ->
			let reg = GetTriggeringRegion()
			let level = reg.getData<Level>()
			if not level.finished and not level.started
				level.onEnter(EventData.getEnteringUnit())

		EventListener.add(EVENT_PLAYER_LEAVE) ->
			for level in levels
				level.onPlayerLeave(EventData.getTriggerPlayer())

		EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
			let u = EventData.getDyingUnit()
			if customHeroes.has(u)
				for level in levels
					level.onCustomHeroDeath(u)

		EventListener.add(EVENT_PLAYER_UNIT_DEATH) -> 
			let u = EventData.getDyingUnit()
			for level in levels
				if not level.finished and level.started and level.aliveEnemies.get(level.waveCount - 1).has(u)
					level.onEnemyDeath(u)

		EventListener.add(EVENT_PLAYER_HERO_REVIVE_FINISH) ->
			let u = EventData.getTriggerUnit()
			for level in levels
				if not level.finished and level.started and level.deadEnemies.get(level.waveCount - 1).has(u)
					level.onEnemyRevived(u)

	
init
	Level.initClass()