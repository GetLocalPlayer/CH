package ChargedStrike
import Assets
import ObjectIdGenerator
import AbilityObjEditing
import AbilityTooltipGenerator
import AssassinShop
import AttackModifier

import LinkedListModule
import ClosureTimers
import LigthingEx


public abstract class ChargedStrike
	static constant int SHOP_COST = 1
	static constant int LEVELS = 5
	static constant ICON = Icons.pASBTNStormHammer
	static constant NAME = "Charged Strike"
	static constant DESCRIPTION = "Gives a chance to hurl a lightning on each hit that bounces to nearby enemies.|n|n[|cffff0000Attack Modifier|r]"
	static constant int CHANCE = 40
	static constant int NUMBER_OF_TARGETS = 5
	static constant real array DAMAGE = [50., 70., 90., 110., 130.]
	static constant real BOUNCE_RANGE = 450.
	static constant real LIFETIME = 1.
	static constant real BOUNCE_DELAY = 0.5

	static constant LIGHT_TYPE = LIGHTNING_CHAIN_LIGHTNING_SEECONDARY
	static constant LIGHT_OFFSET = vec3(0, 0, 75)

	static constant FX_TARGET = Abilities.boltImpact
	static constant FX_ATTACH_TARGET = "origin"
	/** Units that will be taken in account on bouncing, ignoring the targets allowed 
	condition. Basically, used only in the active effect of "Lightning Rod" item. */
	static let additionalTargets = CreateGroup()

	static constant ID = compiletime(ABIL_ID_GEN.next())

	use LinkedListModule

	static function onBounce(ChargedStrike cb) returns ChargedStrike
		return cb

	protected abstract function run(unit target)

	@compiletime protected static function build()
		let tooltipGen = new AbilityTooltipGenerator(NAME, DESCRIPTION)
		new AttackModifier(ID, LEVELS, tooltipGen)
		..setIconNormal(ICON)
		..setArtTarget("")
		..setHeroAbility(true)
		..setRequirements("")
		..setRace(Race.Human)
		..setName(NAME)
		..registerTooltipGenerator(tooltipGen)
		..tooltipStartListen()
		..addTooltipProperty("Chance", (int lvl) -> CHANCE.toString())
		..addTooltipProperty("Damage", (int lvl) -> DAMAGE[lvl - 1].toInt())
		..addTooltipProperty("Number of Targets", (int lvl) -> NUMBER_OF_TARGETS)
		..presetAreaofEffect((lvl) -> BOUNCE_RANGE)
		..tooltipStopListen()
		assassinShopDef.addAbilitySold(ID, true, ICON, NAME, tooltipGen.getTooltipLearnExtended(), SHOP_COST)

	protected static function onInit()
		Preload(FX_TARGET)

		AttackModifier.onHit(ID) (unit caster, unit target, int level) ->
			let proc = GetRandomInt(1, 100) <= CHANCE
			if proc
				apply(caster, target, DAMAGE[level - 1])
			return proc
			
	static function apply(unit caster, unit target, real damage)
		let affectedUnits = CreateGroup()
		..add(target)
		caster.damageTarget(target, damage, false, false, ATTACK_TYPE_NORMAL, DAMAGE_TYPE_LIGHTNING, WEAPON_TYPE_WHOKNOWS)
		new LigthingEx(LIGHT_TYPE, caster, target, LIGHT_OFFSET, LIGHT_OFFSET)
		..setLifetime(LIFETIME)
		..setFadepoint(LIFETIME)
		flashEffect(FX_TARGET, target, FX_ATTACH_TARGET)
		var _previousTarget = target
		doPeriodicallyCounted(BOUNCE_DELAY, NUMBER_OF_TARGETS - 1) (CallbackCounted cb) ->
			let prevPos = _previousTarget.getPos()
			ENUM_GROUP.enumUnitsInRange(prevPos, BOUNCE_RANGE + MAX_COLLISION_SIZE)
			for u in ENUM_GROUP
				if not u.isAlive() or not u.isEnemyOf(caster) or target.isType(UNIT_TYPE_MAGIC_IMMUNE) or affectedUnits.has(u) or not u.isInRange(prevPos, BOUNCE_RANGE)
					ENUM_GROUP.remove(u)
			for u in additionalTargets
				if not affectedUnits.has(u) and u.isInRange(prevPos, BOUNCE_RANGE)
					ENUM_GROUP.add(u)
			let randomUnit = ENUM_GROUP.getRandom()
			ENUM_GROUP.clear()
			if randomUnit != null
				caster.damageTarget(randomUnit, damage, false, false, ATTACK_TYPE_NORMAL, DAMAGE_TYPE_LIGHTNING, WEAPON_TYPE_WHOKNOWS)
				new LigthingEx(LIGHT_TYPE, _previousTarget, randomUnit, LIGHT_OFFSET, LIGHT_OFFSET)
				..setLifetime(LIFETIME)
				..setFadepoint(LIFETIME)
				flashEffect(FX_TARGET, randomUnit, FX_ATTACH_TARGET)
				_previousTarget = randomUnit
				affectedUnits.add(randomUnit)
				for cb in ChargedStrike
					cb.run(randomUnit)
			else
				destroy cb
			
init
	ChargedStrike.onInit()
